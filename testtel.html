<!doctype html>
<html lang="fr">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Solo</title>
    <link rel="icon" type="image/png" sizes="64x64" href="./favicon.png">
    <!-- Charger la bibliothèque Phaser pour créer des jeux 2D -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
</head>
<style>
    /* Supprimer les marges par défaut du navigateur */
    body {
        margin: 0;
        background-color: rgb(65, 61, 61);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        touch-action: none;
    }

    /* Le jeu */
    canvas {
        border: 4px solid rgb(41, 21, 21);
        touch-action: none;
    }
</style>

<body>

    <img src="assets/logohome.png" alt="Home"
        style="cursor:pointer; width:105px; position: fixed; top: 10px; left: 10px; z-index: 1000;"
        onclick="window.location.href='./index.html'">
    <img src="assets/logoretour.png" alt="Retour"
        style="cursor:pointer; width:105px; position: fixed; top: 10px; left: 125px; z-index: 1000;"
        onclick="window.location.href='./index.html'">
    <img src="assets/logorefresh.png" alt="Actualiser"
        style="cursor:pointer; width:105px; position: fixed; top: 10px; right: 10px; z-index: 1000;"
        onclick="window.location.href='./solo.html'">

    <div id="game-wrapper" class="game-wrapper"></div>

    <script>
        // Variables pour les contrôles mobiles
        let lastVolume = null;
        let movingLeft = false;
        let movingRight = false;

        // Détecter les changements de volume pour les contrôles
        if ('mediaSession' in navigator) {
            // Tenter de détecter les changements de volume
            document.addEventListener('volumechange', handleVolumeChange);
        }

        // Fonction pour gérer les changements de volume
        function handleVolumeChange(event) {
            // Cette approche utilise l'API Media Session
            // Note: La détection de volume est limitée dans les navigateurs mobiles
        }

        // Alternative: Détecter les touches de volume via keydown
        document.addEventListener('keydown', function(e) {
            if (e.key === 'VolumeDown' || e.keyCode === 174) {
                e.preventDefault();
                movingLeft = true;
                movingRight = false;
            } else if (e.key === 'VolumeUp' || e.keyCode === 175) {
                e.preventDefault();
                movingRight = true;
                movingLeft = false;
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === 'VolumeDown' || e.keyCode === 174) {
                movingLeft = false;
            } else if (e.key === 'VolumeUp' || e.keyCode === 175) {
                movingRight = false;
            }
        });

        // Configuration du jeu Phaser
        var config = {
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scene: { preload, create, update },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        // Créer une nouvelle instance du jeu
        new Phaser.Game(config);

        // ===== Variables globales du jeu =====
        var player;
        var cursors;
        var stars;
        var bombs;
        var platforms;
        var score = 0, scoreText;
        var lives = 3, lifeIcons = [];
        var gameOver = false;

        // Variables pour gérer les niveaux
        var currentLevel = 0;
        var platformsArray = [];
        var tremplin = null;

        // Différentes dispositions de plateformes pour chaque niveau
        var platformLayouts = [
            [{ x: 600, y: 400 }, { x: 50, y: 250 }, { x: 750, y: 220 }],
            [{ x: 150, y: 350 }, { x: 400, y: 200 }, { x: 650, y: 300 }, { x: 400, y: 470 }],
            [{ x: 700, y: 250 }, { x: 80, y: 150 }, { x: 500, y: 400 }],
            [{ x: 300, y: 420 }, { x: 40, y: 200 }, { x: 650, y: 120 }, { x: 400, y: 300 }],
            [{ x: 200, y: 380 }, { x: 40, y: 140 }, { x: 600, y: 240 }, { x: 350, y: 100 }],
            [{ x: 200, y: 150 }, { x: 500, y: 310 }, { x: 700, y: 180 }, { x: 350, y: 460 }],
            [{ x: 100, y: 380 }, { x: 300, y: 250 }, { x: 500, y: 150 }, { x: 700, y: 250 }],
            [{ x: 50, y: 380 }, { x: 250, y: 200 }, { x: 450, y: 100 }, { x: 650, y: 200 }],
            [{ x: 400, y: 380 }, { x: 200, y: 250 }, { x: 600, y: 150 }],
            [{ x: 100, y: 500 }, { x: 300, y: 350 }, { x: 500, y: 200 }, { x: 700, y: 100 }]
        ];

        function preload() {
            this.load.image('sky', 'assets/sky.png');
            this.load.image('ground', 'assets/platform.png');
            this.load.image('star', 'assets/piece.png', { frameWidth: 3, frameHeight: 3 });
            this.load.image('bomb', 'assets/bombe.png', { frameWidth: 3, frameHeight: 3 });
            this.load.image('vie', 'assets/vie1.png');
            this.load.image('novie', 'assets/vie2.png');
            this.load.image('tremplin', 'assets/tremplin.png');

            const selectedChar = localStorage.getItem('selectedCharacter') || '1';
            this.load.spritesheet('dude', `assets/personnageframe${selectedChar}.png`, {
                frameWidth: 320,
                frameHeight: 480
            });
        }

        function create() {
            const scene = this;
            
            // Ajouter l'image du ciel en arrière-plan
            this.add.image(config.width / 2, config.height / 2, 'sky')
                .setDisplaySize(config.width, config.height);

            // Afficher le score en haut à gauche
            scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#000' });

            // Créer les icônes de vies en haut à gauche
            for (let i = 0; i < lives; i++) {
                let icon = this.add.image(40 + i * 45, 70, 'vie').setScale(0.02);
                lifeIcons.push(icon);
            }

            function createPlatformsForLevel(level) {
                // Supprimer anciennes plateformes
                platformsArray.forEach(p => p.destroy());
                platformsArray = [];

                // Supprimer le tremplin s'il existe
                if (tremplin) {
                    tremplin.destroy();
                    tremplin = null;
                }

                // Créer plateformes du niveau
                platformLayouts[level].forEach(pos => {
                    platformsArray.push(platforms.create(pos.x, pos.y, 'ground'));
                });

                // Ajouter le tremplin UNIQUEMENT au level 1 (index 1)
                if (level === 1) {
                    tremplin = platforms.scene.physics.add.staticSprite(387, 514, 'tremplin');
                    tremplin.setScale(0.04);
                    tremplin.refreshBody();

                    platforms.scene.physics.add.collider(player, tremplin, bounceOnTrampoline, null, platforms.scene);
                    platforms.scene.physics.add.collider(stars, tremplin);
                    platforms.scene.physics.add.collider(bombs, tremplin);
                }
            }

            function bounceOnTrampoline(player, tremplin) {
                player.setVelocityY(-600);
            }

            // Créer le groupe statique de plateformes
            platforms = this.physics.add.staticGroup();
            platforms.create(config.width / 2, config.height - 32, 'ground')
                .setScale(2)
                .refreshBody();

            // Créer les plateformes du niveau 0
            createPlatformsForLevel(0);

            // Créer le personnage du joueur
            player = this.physics.add.sprite(100, 450, 'dude');
            player.setScale(0.125);
            player.setBounce(0.2);
            player.setCollideWorldBounds(true);

            // Créer les animations
            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

            this.anims.create({
                key: 'turn',
                frames: [{ key: 'dude', frame: 4 }],
                frameRate: 20
            });

            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });

            // ===== CONTRÔLES TACTILES POUR MOBILE =====
            // Toucher l'écran pour sauter
            this.input.on('pointerdown', function(pointer) {
                if (!gameOver && player.body.touching.down) {
                    player.setVelocityY(-330);
                }
            });

            // Récupérer les touches du clavier (désactivé pour mobile mais gardé dans le code)
            cursors = this.input.keyboard.createCursorKeys();

            // Créer les étoiles à collecter
            stars = this.physics.add.group({ 
                key: 'star', 
                repeat: 11, 
                setXY: { x: 12, y: 0, stepX: 70 } 
            });
            stars.children.iterate(c => {
                c.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
                c.setScale(0.015);
            });

            // Créer le groupe des bombes
            bombs = this.physics.add.group();

            // Configurer les collisions et chevauchements
            this.physics.add.collider(player, platforms);
            this.physics.add.collider(stars, platforms);
            this.physics.add.collider(bombs, platforms);
            this.physics.add.overlap(player, stars, collectStar, null, this);
            this.physics.add.collider(player, bombs, hitBomb, null, this);
            this.physics.add.collider(stars, tremplin);
            this.physics.add.collider(bombs, tremplin);
            this.physics.add.collider(player, tremplin, bounceOnTrampoline, null, this);
        }

        function update() {
            if (gameOver) return;

            // Gérer les déplacements avec les boutons de volume
            if (movingLeft) {
                player.setVelocityX(-160);
                player.anims.play('left', true);
            } else if (movingRight) {
                player.setVelocityX(160);
                player.anims.play('right', true);
            } else {
                player.setVelocityX(0);
                player.anims.play('turn');
            }
        }

        function collectStar(player, star) {
            star.disableBody(true, true);
            score += 10;
            scoreText.setText('Score: ' + score);

            if (stars.countActive(true) === 0) {
                changeLevel();

                let x = (player.x < config.width / 2) ? 
                    Phaser.Math.Between(config.width / 2, config.width) : 
                    Phaser.Math.Between(0, config.width / 2);
                let bomb = bombs.create(x, 16, 'bomb');
                bomb.setScale(0.015);
                bomb.body.setSize(
                    bomb.width * 0.015,
                    bomb.height * 0.015
                );
                bomb.body.setOffset(
                    bomb.width * 0.015,
                    bomb.height * 0.015
                );
                bomb.setBounce(1).setCollideWorldBounds(true);
                bomb.setVelocity(Phaser.Math.Between(-200, 200), 20);

                stars.children.iterate(c => c.enableBody(true, c.x, 0, true, true));
            }
        }

        function hitBomb(player, bomb) {
            bomb.disableBody(true, true);
            lives--;

            if (lives >= 0) {
                lifeIcons[lives]
                    .setTexture('novie')
                    .setScale(0.02);
            }

            if (lives <= 0) {
                this.physics.pause();
                player.setTint(0xff0000);
                player.anims.play('turn');
                gameOver = true;
            }
        }

        function createPlatformsForLevel(level) {
            platformsArray.forEach(p => p.destroy());
            platformsArray = [];

            platformLayouts[level].forEach(pos => {
                platformsArray.push(platforms.create(pos.x, pos.y, 'ground'));
            });
        }

        function changeLevel() {
            currentLevel = (currentLevel + 1) % platformLayouts.length;
            createPlatformsForLevel(currentLevel);
        }
    </script>
</body>

</html>
